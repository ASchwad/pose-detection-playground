/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.0 Cubeman.gltf --transform 
Files: Cubeman.gltf [19.76KB] > /Users/aschwad/Documents/Code/pose-detection/src/components/Cubeman/Cubeman-transformed.glb [15.67KB] (21%)
*/

import React, { useEffect } from 'react'
import { useGraph } from '@react-three/fiber'
import { useGLTF, useAnimations } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'
import { Keypoint } from '@tensorflow-models/pose-detection'
import { Matrix4, Mesh, SkinnedMesh, Vector3 } from 'three'
import { adjustKeypointsToOrigin } from '@/lib/dimensionalCalculations'

interface CubemanProps {
  poseKeypoints: Keypoint[]
}

const cubeman_node_keys = [
  "Scene",
  "Armature",
  "Spine",
  "Shoulderl",
  "Arml",
  "Handl",
  "Hipl",
  "Upperlegl",
  "Lowerlegl",
  "Shoulderr",
  "Armr",
  "Handr",
  "Hipr",
  "Upperlegr",
  "Lowerlegr",
  "Cube002"
]

export function Cubeman({ poseKeypoints }: CubemanProps) {
  const group = React.useRef(null)
  const { scene, animations } = useGLTF('/Cubeman-transformed.glb')
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone)
  const { actions, clips } = useAnimations(animations, group)

  function positionJointBasedOnKeypoint(keypoint: Keypoint, referenceJoint: any, targetJoint: any) {
    if (!referenceJoint || !targetJoint) {
        console.error('Reference joint or target joint not found');
        return;
    }

    // Convert keypoint to global coordinate (adjust according to your coordinate system)
    const inputCoordinate = new Vector3(
        // (keypoint.x - 355) / 40,
        // - (keypoint.y - 380) / 40,
        keypoint.x,
        keypoint.y,
        keypoint.z? keypoint.z : 0
    );

    // 1. Get the world matrix of the reference joint
    const referenceWorldMatrix = new Matrix4();
    referenceJoint.updateWorldMatrix(true, false);
    referenceWorldMatrix.copy(referenceJoint.matrixWorld);

    // 2. Calculate the inverse of the reference joint's world matrix
    const inverseReferenceWorldMatrix = referenceWorldMatrix.clone().invert();

    // 3. Convert the input coordinate to local space relative to the reference joint
    const inputLocalPosition = inputCoordinate.clone().applyMatrix4(inverseReferenceWorldMatrix);

    // 4. Set the position of the target joint in its local space
    targetJoint.position.copy(inputLocalPosition);
  }

 

  useEffect(() => {
    if(nodes && poseKeypoints.length > 0) {
      console.log(actions)
      console.log(animations)
      console.log(Object.keys(nodes))

      const correctedKeypoints = adjustKeypointsToOrigin({ keypoints: poseKeypoints, zScaleDownRatio: 150 })
      

      console.log(correctedKeypoints)
      const centerX = (correctedKeypoints.find((keypoint) => keypoint.name === "left_hip")?.x! + correctedKeypoints.find((keypoint) => keypoint.name === "right_hip")?.x!) / 2
      const centerY = (correctedKeypoints.find((keypoint) => keypoint.name === "left_hip")?.y! + correctedKeypoints.find((keypoint) => keypoint.name === "right_hip")?.y!) / 2
      nodes.Spine.position.setX(centerX)
      nodes.Spine.position.setY(-centerY)
      
      const left_wrist_keypoint = correctedKeypoints.find((keypoint) => keypoint.name === "left_wrist")
      const left_foot_keypoint = correctedKeypoints.find((keypoint) => keypoint.name === "left_ankle")
      const left_knee_keypoint = correctedKeypoints.find((keypoint) => keypoint.name === "left_knee")
      
      positionJointBasedOnKeypoint(left_wrist_keypoint!, nodes["Arml"], nodes["Handl"])
      positionJointBasedOnKeypoint(left_knee_keypoint!, nodes["Hipl"], nodes["Upperlegl"])
      positionJointBasedOnKeypoint(left_foot_keypoint!, nodes["Upperlegl"], nodes["Lowerlegl"])
      const right_wrist_keypoint = correctedKeypoints.find((keypoint) => keypoint.name === "right_wrist")
      const right_foot_keypoint = correctedKeypoints.find((keypoint) => keypoint.name === "right_ankle")
      const right_knee_keypoint = correctedKeypoints.find((keypoint) => keypoint.name === "right_knee")
      
      positionJointBasedOnKeypoint(right_wrist_keypoint!, nodes["Armr"], nodes["Handr"])
      positionJointBasedOnKeypoint(right_knee_keypoint!, nodes["Hipr"], nodes["Upperlegr"])
      positionJointBasedOnKeypoint(right_foot_keypoint!, nodes["Upperlegr"], nodes["Lowerlegr"])
    }else{
      nodes.Spine.position.setX(0)
      nodes.Spine.position.setY(-1)
      nodes.Spine.position.setZ(0)
    }

    // play clip
    // actions['ArmatureAction'].play()

  }, [nodes, poseKeypoints])
  
  return (
    <group ref={group} dispose={null}>
      <group name="Scene">
        <group name="Armature" position={[0, 1.821, 0]} scale={0.7}>
          <primitive object={nodes.Spine} />
        </group>
        {/* <mesh
          name="Sphere"
          geometry={(nodes.Sphere as Mesh).geometry}
          material={(nodes.Sphere as Mesh).material}
        /> */}
        <skinnedMesh
          name="Cube002"
          geometry={(nodes.Cube002 as SkinnedMesh).geometry}
          material={(nodes.Cube002 as SkinnedMesh).material}
          skeleton={(nodes.Cube002 as SkinnedMesh).skeleton}
          position={[0, 1.821, 0]}
          scale={0.537}
        />
      </group>
    </group>
  )
}

useGLTF.preload('/Cubeman-transformed.glb')

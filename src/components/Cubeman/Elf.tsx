/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.0 Cubeman.gltf --transform 
Files: Cubeman.gltf [19.76KB] > /Users/aschwad/Documents/Code/pose-detection/src/components/Cubeman/Cubeman-transformed.glb [15.67KB] (21%)
*/

import { useAnimations, useGLTF } from '@react-three/drei'
import { useGraph } from '@react-three/fiber'
import { Keypoint } from '@tensorflow-models/pose-detection'
import React, { useEffect } from 'react'
import { Quaternion, Vector3 } from 'three'
import { SkeletonUtils } from 'three-stdlib'

import { adjustKeypointsToOrigin } from '@/lib/dimensionalCalculations'

interface ElfProps {
  poseKeypoints: Keypoint[]
}

// Comprehensive mapping from pose keypoints to Elf skeleton bones

export function Elf({ poseKeypoints }: ElfProps) {
  const group = React.useRef(null)
  const { scene, animations } = useGLTF('/elf.glb')
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes } = useGraph(clone)
  useAnimations(animations, group)

  useEffect(() => {
    console.log('Elf:', nodes)
    if (nodes && poseKeypoints.length > 0) {
      console.log('Key points ready')
      console.log('Elf nodes:', Object.keys(nodes))
      console.log('Pose keypoints:', poseKeypoints)

      const correctedKeypoints = adjustKeypointsToOrigin({
        keypoints: poseKeypoints,
        zScaleDownRatio: 150
      })

      console.log('Corrected keypoints:', correctedKeypoints)

      // Find the main body/root node - this might be different for the elf model
      const rootNode =
        nodes['Scene'] || nodes['Armature'] || nodes['Bip001_Spine']

      if (rootNode) {
        // Set the root position based on hip center
        const leftHip = correctedKeypoints.find((kp) => kp.name === 'left_hip')
        const rightHip = correctedKeypoints.find(
          (kp) => kp.name === 'right_hip'
        )

        if (leftHip && rightHip) {
          const centerX = (leftHip.x + rightHip.x) / 2
          rootNode.position.setX(centerX)
          rootNode.position.setY(-1)
        }
      }

      // region ROTATION LOGIC
      // This is the new logic that rotates bones to match the pose.
      // It's more stable than setting positions directly.

      // 1. Get Keypoints for a limb
      const rightShoulder = correctedKeypoints.find(
        (kp) => kp.name === 'right_shoulder'
      )
      const rightElbow = correctedKeypoints.find(
        (kp) => kp.name === 'right_elbow'
      )

      // 2. Get the corresponding bones
      const rightUpperArm = nodes['Bip001_R_UpperArm']

      // Helper function to compute rotation
      const computeRotation = (
        fromKP: Keypoint,
        toKP: Keypoint,
        boneDefaultDir: Vector3
      ) => {
        const keypointDir = new Vector3(
          -(toKP.x - fromKP.x), // Invert X axis for correct orientation
          -(toKP.y - fromKP.y), // Y is inverted in screen space
          (toKP.z || 0) - (fromKP.z || 0)
        ).normalize()

        return new Quaternion().setFromUnitVectors(boneDefaultDir, keypointDir)
      }

      // 3. Animate the Right Arm
      if (rightShoulder && rightElbow && rightUpperArm) {
        // The default direction of the bone in your model's bind pose.
        // This might be (1,0,0), (0,1,0), or (0,0,1) depending on how it was rigged.
        // You may need to experiment to find the correct axis.
        const upperArmDefaultDir = new Vector3(0, 0, 0)
        const quat = computeRotation(
          rightShoulder,
          rightElbow,
          upperArmDefaultDir
        )
        rightUpperArm.quaternion.slerp(quat, 1.0) // Use 1.0 for direct application
      }

      // if (rightElbow && rightWrist && rightForearm) {
      //   const forearmDefaultDir = new Vector3(0, 0, 0)
      //   const quat = computeRotation(rightElbow, rightWrist, forearmDefaultDir)
      //   rightForearm.quaternion.slerp(quat, 1.0) // Use 1.0 for direct application
      // }

      // endregion

      // region OLD POSITION LOGIC (COMMENTED OUT)
      /*
      // Apply keypoints to bones using the comprehensive mapping
      ELF_KEYPOINT_MAPPINGS.forEach(({ keypoint, bone }) => {
        const keypointData = correctedKeypoints.find(
          (kp) => kp.name === keypoint
        )
        const boneNode = nodes[bone]

        if (keypointData && boneNode) {
          console.log(`Applying ${keypoint} to ${bone}`)

          // Calculate relative position from root
          const rootNode = nodes['Bip001_Spine']
          if (rootNode) {
            const relativeX = keypointData.x - rootNode.position.x
            const relativeY = keypointData.y - rootNode.position.y
            const relativeZ = (keypointData.z || 0) - rootNode.position.z

            // Apply position with some scaling for better fit
            boneNode.position.set(
              relativeX * 0.5, // Scale down for better fit
              relativeY * 0.5,
              relativeZ * 0.5
            )
          } else {
            // Fallback to direct positioning
            boneNode.position.set(
              keypointData.x,
              keypointData.y,
              keypointData.z || 0
            )
          }
        }
      })

      // Additional bone chain mappings for more realistic movement
      // Map spine chain
      const spineChain = ['Bip001_Spine', 'Bip001_Spine1', 'Bip001_Spine2']
      const leftShoulder = correctedKeypoints.find(
        (kp) => kp.name === 'left_shoulder'
      )
      const rightShoulder = correctedKeypoints.find(
        (kp) => kp.name === 'right_shoulder'
      )

      if (leftShoulder && rightShoulder) {
        spineChain.forEach((boneName, index) => {
          const boneNode = nodes[boneName]
          if (boneNode) {
            const progress = index / (spineChain.length - 1)
            const interpolatedX =
              leftShoulder.x + (rightShoulder.x - leftShoulder.x) * progress
            const interpolatedY =
              leftShoulder.y + (rightShoulder.y - leftShoulder.y) * progress

            boneNode.position.setX(interpolatedX * 0.3)
            boneNode.position.setY(-interpolatedY * 0.3)
          }
        })
      }
      */
      // endregion
    }
  }, [nodes, poseKeypoints, clone])

  return (
    <>
      <group ref={group} scale={10} rotation={[0, Math.PI, 0]}>
        {clone && <primitive object={clone} />}
      </group>
    </>
  )
}

useGLTF.preload('/elf.glb')
